// Generated by CoffeeScript 1.9.1
var Header, Lexer, constants,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Lexer = require('./lexer');

constants = require('./constants');

Header = (function() {
  function Header(data) {
    this["var"] = bind(this["var"], this);
    this.var_list = bind(this.var_list, this);
    this.attr = bind(this.attr, this);
    this.att_list = bind(this.att_list, this);
    this.name = bind(this.name, this);
    this.dim = bind(this.dim, this);
    this.dim_list = bind(this.dim_list, this);
    this.numrecs = bind(this.numrecs, this);
    this.magic = bind(this.magic, this);
    this.header = bind(this.header, this);
    this.lex = new Lexer(data);
  }

  Header.prototype.header = function() {
    return {
      version: this.magic(),
      records: this.numrecs(),
      dimensions: this.dim_list(),
      globalattributes: this.att_list(),
      attributes: this.att_list(),
      variables: this.var_list()
    };
  };

  Header.prototype.magic = function() {
    var description, magicstring, version;
    magicstring = this.lex.string(3);
    if (magicstring !== 'CDF') {
      throw new Error('Not a valid NetCDF file ' + magicstring);
    }
    version = this.lex.byte();
    if (version !== 1 && version !== 2 && version !== 3) {
      throw new Error("Unknown NetCDF format (version " + version + ")");
    }
    if (version === 1) {
      description = 'Classic format';
    }
    if (version === 2) {
      description = '64 bit offset format';
    }
    return {
      number: version,
      description: description
    };
  };

  Header.prototype.numrecs = function() {
    var numrecs;
    if (this.lex.match(constants.streamingMarker)) {
      this.lex.forward(constants.streamingMarker.length);
      return {
        type: 'streaming'
      };
    } else {
      numrecs = this.lex.uint32();
      return {
        type: 'fixed',
        number: numrecs
      };
    }
  };

  Header.prototype.dim_list = function() {
    var count, i, results;
    if (this.lex.match(constants.zeroMarker)) {
      this.lex.forward(constants.zeroMarker.length);
      return null;
    }
    if (!this.lex.match(constants.dimensionMarker)) {
      throw new Error('Dimension marker not found');
    }
    this.lex.forward(constants.dimensionMarker.length);
    count = this.lex.uint32();
    if (count === 0 && this.lex.uint32() !== constants.zeroMarker) {
      throw new Error('No dimensions and no absent marker present');
    }
    return (function() {
      results = [];
      for (var i = 0; 0 <= count ? i < count : i > count; 0 <= count ? i++ : i--){ results.push(i); }
      return results;
    }).apply(this).map((function(_this) {
      return function() {
        return _this.dim();
      };
    })(this));
  };

  Header.prototype.dim = function() {
    var dim, ref;
    dim = {
      name: this.name(),
      length: (ref = this.lex.uint32()) != null ? ref : 0
    };
    if (dim.length === 0) {
      dim.length = null;
    }
    return dim;
  };

  Header.prototype.name = function() {
    var length, res;
    length = this.lex.uint32();
    res = this.lex.string(length);
    this.lex.fill(length);
    return res;
  };

  Header.prototype.att_list = function() {
    var attr, count, i, ref, res;
    if (this.lex.match(constants.zeroMarker)) {
      this.lex.forward(constants.zeroMarker.length);
      return null;
    }
    if (!this.lex.match(constants.attributeMarker)) {
      throw new Error('Attribute marker not found');
    }
    this.lex.forward(constants.attributeMarker.length);
    count = this.lex.uint32();
    if (count === 0 && this.lex.uint32() !== constants.zeroMarker) {
      throw new Error('No attributes and no absent marker present');
    }
    res = {};
    for (i = 0, ref = count; 0 <= ref ? i < ref : i > ref; 0 <= ref ? i++ : i--) {
      attr = this.attr();
      res[attr.name] = attr.value;
    }
    return res;
  };

  Header.prototype.attr = function() {
    return {
      name: this.name(),
      value: this.lex.reader(this.lex.type())(this.lex.uint32())
    };
  };

  Header.prototype.var_list = function() {
    var count, i, ref, res, variable;
    if (this.lex.match(constants.zeroMarker)) {
      this.lex.forward(constants.zeroMarker.length);
      return null;
    }
    if (!this.lex.match(constants.variableMarker)) {
      throw new Error('Variable marker not found');
    }
    this.lex.forward(constants.variableMarker.length);
    count = this.lex.uint32();
    if (count === 0 && this.lex.uint32() !== constants.zeroMarker) {
      throw new Error('No variables and no absent marker present');
    }
    res = {};
    for (i = 0, ref = count; 0 <= ref ? i < ref : i > ref; 0 <= ref ? i++ : i--) {
      variable = this["var"]();
      res[variable.name] = variable.value;
    }
    return res;
  };

  Header.prototype["var"] = function() {
    var i, ref, results;
    return {
      name: this.name(),
      value: {
        dimensions: (function() {
          results = [];
          for (var i = 0, ref = this.lex.uint32(); 0 <= ref ? i < ref : i > ref; 0 <= ref ? i++ : i--){ results.push(i); }
          return results;
        }).apply(this).map((function(_this) {
          return function() {
            return _this.lex.uint32();
          };
        })(this)),
        attributes: this.att_list(),
        type: this.lex.type(),
        size: this.lex.uint32(),
        offset: this.lex.uint32()
      }
    };
  };

  return Header;

})();

module.exports = function(data) {
  return new Header(data).header();
};
